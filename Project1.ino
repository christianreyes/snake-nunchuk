/*========================================================*//*

Christian Reyes

Carnegie Mellon University
05-833 Gadgets, Sensors, and Activity Recognition in Human-Computer Interaction

2/23/2012

Project 1: LED 8x8 Matrix Game

------------ Snake Nunchuck -----------------

Classic snake game implemented on Arduino.

Uses the Wii Nunchuck joystick as the interaction device. User moves
around the grid and eats the food which is running all over the board.

The game ends when the snake eats itself.

------------ Wii Nunchuck ------------------

I used the "WiiChuck" Wii Nunchuck Adapter: 

http://todbot.com/blog/2008/02/18/wiichuck-wii-nunchuck-adapter-available/

The most recent WiiChuck library can be found at:

https://github.com/todbot/wiichuck_adapter

The WiiChuck communicates over I2C which uses the SDA and SLC pins (A4 and A5) to
communicate with the Wii Nunchuck.

The Wii Nunchuck has a triple-axis accelerometer, two buttons, and a joystick. The
joystick is implemented using two potentiometers and thus gives you the ability to
read input for any angle.

Simply copy "nunchuck_funcs.h" into your project folder and #include "nunchuck_funcs.h"
it in to get access to the functions.

*//*========================================================*/

#include <Wire.h>              // Library protocol used to communicate with the Wii Nunchuck
#include "nunchuck_funcs.h"    // Library to access the data from the Wii Nunchuck
#include "enemy.h"             // Header file for the enemy blocks
#include "body.h"              // Header file for the body blocks


// Pin declarations   1   2   3   4   5   6   7   8
const int col[8] = { 13,  1, 11 , 7,  0, A0,  4, A3 };
const int row[8] = {  6,  2,  8 , 5, A1,  9, A2, 10 };

const int MAXLENGTH = 64;      // max length for the snake

int length = 1;                // current length of the snake
body snake[MAXLENGTH];         // body parts for the snake
body *head = &snake[0];        // head points to the 1st element in the body parts

unsigned long timex = 0;       // time since last x input
unsigned long timey = 0;       // time since last y input

boolean dead = false;          // track if user is dead

int timeenemy = 0;             // time since enemies last moved
int dim = 0;                   // used to track the time since the enemy was last displayed
                               // display the enemies every 2 frames

const int NUMENEMIES = 4;      // number of enemies on screen
enemy enemies[NUMENEMIES];     // array for holding the enemies

/*-------------------------------------------*/
/* Initializization code (run once via call from Arduino framework) */

void setup() {
  pinSetup();                  // establish direction of pins we are using to drive LEDs 
  testPattern();               // display a test pattern to check if LEDs are connected properly
  smilieTest();                // smilie test pattern
  
  //Serial.begin(9600);        // Start serial communication with computer

  randomSeed(analogRead(A7));  // Set the seed for random to a "random" value so that the numbers 
                               // generated by random() will be different every run
  nunchuck_init();             // send the initilization handshake
  
  for(int i=0;i<NUMENEMIES;i++){ 
    enemies[i] = generateEnemy(); 
  }
  
  head->x = random(1,9);
  head->y = random(1,9); 
}

/* Main routine (called repeated by from the Arduino framework) */
void loop() {
  updateDisplay();            
  moveEnemies();
  if(!dead){
    processUserInput();
  }
  else{ // "reset" the game
    dead = false;
    for(int i=1;i<MAXLENGTH;i++){ // zero out the body except for the head
      body b;
      snake[i] = b;
    }
    head->x = random(1,9);        // set the head to a new value
    head->y = random(1,9);
    length = 1;                   // set length to original value
  }

  /*
  Serial.println("current snake");
  for(int i=0;i<length;i++){
    Serial.print(String(snake[i].x) + "," + String(snake[i].y) + " ");  
  }
  Serial.println("");
  */
}  // end loop()

void updateDisplay(){
  for(int r=0; r<8; r++){
    digitalWrite( row[r], LOW);            // prepare row to be lit
    
    for(int i=0;i<length;i++){             
      body b = snake[i];
      if( b.y == (r+1) ){                  // if body part is in the row, draw it
        digitalWrite( col[b.x - 1], HIGH);
      }
    }
    
    if(dim == 1){                          // every two frames, draw the enemies
      for(int i=0; i<NUMENEMIES; i++){     // this will make them appear dim
        enemy e = enemies[i];
        
        if(inThisRow(r, e)){               // if in the row, draw it
          digitalWrite( col[(int)e.x - 1], HIGH);
        }
      }
    }
    
    delayMicroseconds(500);                // every 500 microseconds
    digitalWrite( row[r], HIGH);           // turn the row off
    for(int c=0; c<8; c++){ digitalWrite( col[c], LOW); }  // set all the cols off
   
  }
  
  if(dim == 2){ // increase dim every time display is called
    dim = 0;
  } else { 
    dim++; 
  }
}

void processEating(){
  if(length < MAXLENGTH){
    for(int i=0;i<NUMENEMIES; i++){
      enemy e = enemies[i];
      if(head->x == (int)e.x && head->y == (int)e.y){ // if the head is where an enemy is ,eat it
        body last;
        last.x = snake[length-1].oldx;                // put the new body part at the end
        last.y = snake[length-1].oldy;
        
        snake[length] = last;
        length++;
        
        e = generateEnemy();                          // generate a new enemy to replace the
        enemies[i] = e;                               // eaten enemy
      }
    } 
  }
}

boolean checkEatingSelf(){
  for(int i=0;i<NUMENEMIES;i++){                      
    enemy e = enemies[i];
    
    for(int b=1;b<length;b++){
      if(snake[b].x == head->x && snake[b].y == head->y){
        return true; // return true if the head is at a body part after it has moved
      } 
    }
  }
  
  return false;
}

void moveEnemies(){
  if(dim == 1){                               // only move when the enemy will be drawn
    timeenemy++;
    if(timeenemy > 15){                       // every 15 times this is called, move the enemies
      for(int i=0; i< NUMENEMIES; i++){       
        enemy e = enemies[i];
        
        if(inBounds(e)){                      // if the enemy is in the grid, move it
          e.x += e.magnitude * cos(e.angle);  // trig
          e.y -= e.magnitude * sin(e.angle);  // trig, need to keep in mind y is 
        } else {
          e = generateEnemy();                // generate a new enemy if off the grid
        }
        enemies[i] = e;                       // replace the old enemy with the new 
      }
      timeenemy = 0;                          // reset the enemy move timer
    }
  }
}

void processUserInput(){
  nunchuck_get_data();                        // get the data from the Wii Nunchuck
  
  boolean moved = false;
  
  timex++;
  
  if(timex > 15UL){                      // if received valid x input (and not eating self), move
    if(head->x < 8 && nunchuck_joyx() > 190 && !hittingSecond(1,0)){
      timex = 0;
      head->oldx = head->x;
      head->oldy = head->y;
      head->x += 1;
      moved = true;
    } else if(head->x > 1 && nunchuck_joyx() < 70 && !hittingSecond(-1, 0)){
      timex = 0;
      head->oldx = head->x;
      head->oldy = head->y;
      head->x -= 1;
      moved = true;
    } 
  } else if(timex > 30000UL){
    timex = 0;
  }
  
  if(!moved){
    timey++;
    if(timey > 15UL){                   // if received valid y input (and not eating self), move
      if(head->y > 1 && nunchuck_joyy() > 190 && !hittingSecond(0,-1)){
        timey = 0;
        head->oldx = head->x;
        head->oldy = head->y;
        head->y--;
        moved = true;
      } else if( head->y < 8 && nunchuck_joyy() < 70 && !hittingSecond(0, 1)){
        timey = 0;
        head->oldx = head->x;
        head->oldy = head->y;
        head->y++;
        moved = true;
      } 
    } else if(timey > 30000UL){
      timey = 0;
    }
  }
  
  if(moved){
    for(int i=1;i<length;i++){
      snake[i].oldx = snake[i].x;          // record the old x and y
      snake[i].x = snake[i-1].oldx;        // set the x and y to the body part in front
      snake[i].oldy = snake[i].y;
      snake[i].y = snake[i-1].oldy;
    }
    
    processEating();                       // eat enemy if there is one there
    
    if(checkEatingSelf()){                 // set flag to end game if eating self
      dead = true;
      displayFlash();
    }
  }
}

boolean hittingSecond(int dirx, int diry){
  if(length > 1){
    body second = snake[1];
    return head->x + dirx == second.x && head->y + diry == second.y; 
  } else {                                // check to see if head is where second body part is
    return false;  
  }
}

void displayFlash(){
  for(int i = 0;i<5;i++){
    for(int r=0;r<8;r++){
      digitalWrite(row[r], LOW);
      for(int c=0;c<8;c++){
        digitalWrite(col[c], HIGH);
      }
    }
    delay(200);
    for(int r=0;r<8;r++){
      digitalWrite(row[r], HIGH);
      for(int c=0;c<8;c++){
        digitalWrite(col[c], LOW);
      }
    }
    delay(200);
  }
}

enemy generateEnemy(){
    enemy e;
   
    /*
        25% of the time generate the enemy on the left side
        25% of the time generate the enemy on the top side
        25% of the time generate the enemy on the right side
        25% of the time generate the enemy on the bottom side
    */
    if( random(2) == 0){                        
      e.x = random(1,9);                       
      (random(2) == 0)? e.y = 1 : e.y = 8;
    } else {
      (random(2) == 0)? e.x = 1 : e.x = 8;
      e.y = random(1,9);
    }
    
    e.magnitude = (float)random(1,10) / 6;    // random  bounded magnitude

    int targetx; 
    int targety;
    
    if(random(0,2) == 0){                     // 50% of the time aim for a target in the middle
      targetx = random(4,6);   
      targety = random(4,6);
    } else {
      targetx = head->x;                      // 50% of the time, aim for user
      targety = head->y;
    }
    
    // trig, get the angle between the target and the enemy
    e.angle = atan2((float)-(targety - e.y), (float)targetx - e.x );  
    
    return e;
}

boolean inThisRow(int r, enemy e){
  return (int)e.y == (r+1);
}

boolean inBounds(enemy e){
  // if in the grid
  return ((int)e.y >= 1 && (int)e.y <= 8) && ((int)e.x >= 1 && (int)e.x <= 8);
}

void pinSetup(){
  for(int i=0; i< 8 ; i++){
    pinMode( col[i], OUTPUT);     // declare the pins
    pinMode( row[i], OUTPUT);
    
    digitalWrite( row[i], HIGH );
    digitalWrite( col[i], LOW );
  }
}

void testPattern(){
  for(int r=0;r<8;r++){
    digitalWrite( row[r], LOW);
    for(int c=0;c<8;c++){
      digitalWrite(col[c], HIGH );
      delay(15);
      digitalWrite(col[c], LOW );
    }
    digitalWrite( row[r], HIGH);
  }
}

void smilieTest(){
  int smilie[8][8] = {
    { 0,0,0,0,0,0,0,0 },
    { 0,1,1,0,0,1,1,0 },
    { 0,1,1,0,0,1,1,0 },
    { 0,0,0,0,0,0,0,0 },
    { 0,1,1,0,0,1,1,0 },
    { 0,1,1,1,1,1,1,0 },
    { 0,0,1,1,1,1,0,0 },
    { 0,0,0,0,0,0,0,0 } 
  };
  
  for(int i=0;i<200;i++){
    for(int r=0;r<8;r++){
      digitalWrite( row[r], LOW);
      for(int c=0;c<8;c++){
        if(i>75 && i< 125 && (r==1 || r==2))
          digitalWrite(col[c], LOW);
        else
          digitalWrite(col[c], smilie[r][c] ? HIGH : LOW );
      }
      //delayMicroseconds(650);
      delay(1);
      for(int c=0;c<8;c++){
        digitalWrite(col[c], LOW );
      }
      digitalWrite( row[r], HIGH);
    }
  }
}
